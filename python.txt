types of programming => procedural, functional & Object Oriented Programming...
python => indentation sensitive...
python => every thing in it is object even the function...
first built-in function => print() => print text to the console...
comment => info about file...
comment starts with # in python...
our app contains code + data...
code is the lines you write to manage and deal with data...
variables don't contain data it only refer to it's location in memory...
reserved words in python => help("keywords")...
slicing a string => myString[start:end+1:steps] (end is not included)...
string functions =>
    len() : get string length...
    strip() : remove spaces or specific character if given as parameter from left and right...
    rstrip() : remove spaces or specific character if given as parameter from right...
    lstrip() : remove spaces or specific character if given as parameter from left...
    capitalize() : make every word start with capital letter...
    title() : make every word and every character after digit start with capital letter...
    zfill(number of character) : put zeros to the digit which is less than the character numbers...
    upper() : make string in uppercase letters...
    lower() : make string in lowercase letters...
    type(item) => data type...
    split() => split string into parts using space by default or using another character if given as a parameter...
    rsplit() => split string into parts from right using space by default or using another character if given as a parameter...
    center(num of char, 'char') => put char before and after the string...
    count('word',start,end) => return the number of word repeated in string...
    swapcase() => turns the uppercase char to lowercase char and lowercase char to uppercase char...
    startswith('char',start,end) => return boolean if the section starts with the char...
    endswith('char',start,end) => return boolean if the section ends with the char...
    find(txt,start,end) => to find a substring in a string return 1 or -1...
    index(char,start,end) => return index of char...
    ljust(num of char returned, 'char filled with')...
    rjust(num of char returned, 'char filled with')...
    splitlines() => return the string into a list...
    expandtabs(num of tabs) => control num of tabs in a string...
    replace('old','new',count) => replace string by another...
    join => print('char'.join(list)) => join items together in a string...
    boolean functions =>
        istitle()...
        isspace()...
        islower()...
        isupper()...
        isidentifier()...
        isalpha()...
        isalnum()...
string old way formatting =>
        %s => string...
        %d => integer...
        %f => float...
example of string old formatting => print("my name is %s, I am %d years old, I am a %s in egypt and my rank is : %f" %(myName,myAge,myJob,myRank))
control floating point =>
        %.f => one zero after point...
        %.2f => two zeros after point...
control string length =>
        %.(num of char)s => take the first number of char in the string...
string new way formatting =>
        string.format(variable or string)...
        {:s} => string...
        {:d} => integer...
        {:f} => float...
example of the new formatting way =>
        print("my name is {:s}, I am {:d} years old, I am a {:s} in egypt and my rank is : {:f}" .format(myName,myAge,myJob,myRank))
example of the new new way of formatting =>
        print(f"I'm {myName} and I'm {myAge} years old.")
functions of numbers =>
        int(n) => convert any number to int...
        float(n) => convert any number to float...
        complex(n) => convert any number to complex...
*args as argument in function => used to pass a variable nonKeyWorded number of arguments to that function...
lists =>
        enclosed in square brackets...
        ordered in zero-based way...
        mutable and can be modified: add, delete, edit...
        it's items are not unique...
        can have different data types...
list slicing => myList[start:end]...
list stepping => myList[start:end:no. of steps]
list methods:
        append(item)...
        extend(item)...
        remove(item) => remove the first element in the list...
        sort(reverse=True,False) => sort the list by default reverse = false...
        reverse() => reverse items in the list...
        clear() => empty list...
        copy() => copy items from list to another list...
        count(item) => count the repeating number of the item...
        index(item) => returns the index of item...
        insert(index , item) => insert item before index...
        pop(index) => return the item of the index...
tuples are enclosed between parentheses...
tuples are immutable => items cannot be changed after building...
operators available in strings and lists are also available in tuples...
to make a tuple with one element => myTuple = ("ahmad",)...
set =>
        are enclosed in curly braces...
        not ordered and not indexed...
        indexing and slicing cannot be done...
        has only immutable data types (string, tuple, numbers) not lists and dict...
        items are unique and are not duplicate...
        set intersection => set1 & set2...
        set union => set1 | set2...
        set difference => set1 - set2...
set mathods =>
        clear() => empty set...
        union() => union sets together...
        add() => add item to the set...
        remove() => remove element form the set return error for unfound items...
        discard() => remove element from the set does not return error for unfound items...
        pop() => return element from the set...
        copy() => copy element to another empty set...
        update() => take the items of a set and add them to the another set...
        difference() => take the items found in the first set and not found in the last set without apdating...
        difference_update() => take the items found in the first set and not found in the last set with apdating...
        intersection() => take the common items in the two sets without updating...
        intersection_update() => take the common items in the two sets with updating...
        symmetric_difference() => take the uncommon items from the two sets without updating...
        symmetric_difference_update() => take the uncommon items from the two sets and update the set...
        issuperset() => return true if all items in second set are in the first set and false if not...
        issubset() => return true if all items of the first set are in the second set and false if not...
        isdisjoint() => return true if there is no common items in both sets and false if there...
dictionary =>
        Dict items are enclosed in curly braces...
        Dict items contain key : value...
        Dict key must be immutable as number, string and tuple...
        Dict value is any datatype...
        Dict kay must be unique...
        Dict is not ordered, you access it's elements with key not index...
methods of getting values of dictionary =>
        myDict["key"]...
        myDict.get("key")...
two-dimensional dictionary => dictionary inside of dictionary...
dictionary method =>
        clear() => clear all data in the dict...
        update() => dict.update({key:value, key2:value, ...}) => update dict...
        copy() => dict1.copy(dict2) => shallow copy for the data of b to a...
        keys() => dict.keys() => return all keys of dict...
        values() => dict.values() => return all values of dict...
        setdefault() => dict.setdefault(key , value) => set a default value to the key if there is no value for that key...
        popitem() => return the last added item...
        items() => get all keys and values in the dict and could be assigned to variable...
        fromkeys() => dict.fromkeys(var1 , var2) => make a dictionary from two variables...
boolean values => True Or False...
boolean functions =>
        bool() => take one argument of any data type, return false in the empty data, else return true...
boolean operator => and , or , not...
type conversion methods =>
        str() => convert any type to string...
        tuple() => convert any type to tuple...
        set() => convert any type to set...
        list() => convert any type to list...
        dict() => only can convert tuple and list with nested tuple and list to dictionary...
user input=>
        input(str) => take string as a parameter for the input and enable the user to input any thing...
ternary conditional operator structure => 
        statement if condition is true + if condition + else +  statement if condition is false...
membership operators => in , not in...
iterable object => sequence [list , tuples , set , dict , string of characters]...
continue => stop the iteration on the index we choose to continue, and continue the loop after it...
break => stop the loop completely and exit it...
pass => we put it instead of a block of code to avoid errors and to fill unimplemented function...
types of function =>
        built-in function...
        user-defined function...
        higher order function => function accept function as a parameter...
parameter => elements given to the function when creating and defining it...
arguments => elements given to the function when calling it in the program...
def => define a function or a class...
packing and unpacking function =>
        (*) or (**) + any variable of data type dict or tuple or list => unpacking it into it's items...
        * + parameter or argument(args) => undefined number of args in the function and put them in tuple...
        ** + parameter or argument(args) => undefined number if args in the function and put them in dictionary...
default argument => assign value to the args in the function => must be the last arg...
(*) + tuple => unpacking tuples to it's items...
(**) + dict => unpacking dictionary to its items...
global scope => scope of variable outside a function...
local scope => scope of variable inside a function...
global scope => can be used by functions...
local scope => can only used by it's function...
global keyword => convert the local variable to a global one...
lambda Or anonymous function =>
        it has no name...
        you can call it inline without defining it...
        you can use it in return data from another function...
        lambda is used for simple tasks and def is for large tasks...
        lambda is ine single expression not a block of code...
        lambda function is assigned to a variable...
        'lambda' keyword is used to make lambda function...
file handling function => open(r + "file name and path" , "file mode")...
r => is very important for dealing with the string as a file path...
file handling modes =>
        "a" => append => open file for appending data, create file if not exist...
        "r" => read(default value) => open file for reading, give error if not exist...
        "w" => write => open file for writing, create if not exist...
        "x" => create => create file, give error if file exists...
types of file paths =>
        absolute path => start from the root to the final file name => always better...
        relative path => related only with the directory you are in...
file methods =>
        read(n) => read the content of the file, can take a number of chars as an arg...
        name => read the name of the file...
        mode => read the mode if the file...
        encoding => read the encode of the file...
        readline(n) => read one line from the file, can take the line number as an arg...
        readlines() => read all the lines of the file, but put every single line as an item in a list...
        close() => closes the file, do it after finishing dealing with the file...
        write() => insert Or append a text in the file, create new file if not exists...
        writelines() => insert lines seperately in the file as from a list...
        truncate(n) => take number of chars as arg, cut the rest of the text and let the first num of chars in the file...
        tell() => return the index of the text the cursor of the mouth is pointing at...
        seek(n) => make the cursor point at the index given...
        os.remove("path") => remove file from the system...
built-in functions =>
        all(iterable) => return true if all elements in the element are true else false...
        any(iterable) => return true if at least on element is true else false...
        bin(n) => return the binary number of a decimal digit(int, double, long)...
        id(var) => return the unique address for a variable...
        sum(iterable, start) => calculate the sum of all items in the element from the start...
        round(number, numOfDigits) => change the number to the nearest whole number...
        range(start, end, step) => generate numbers between start and end...
        print() => prints message to the console, sep =" " => seperator, end =" " => line end...
        abs(n) => return the positive value of the number...
        pow(base, exp, mod) => return the power of the base, or modulus if mod is given...
        min(items OR iterable) => return the minimum item...
        max(items OR iterable) => return the maximum item...
        slice(start, end, step) => cut the items of iterable element...
        startswith(char) => check if the string starts with that char...
        map() =>
                take a function + iterator...
                map is called map because it map a function for every element...
                the function can be predefined or lambda...
        filter() =>
                takes a function and iterator...
                filter run a function for every element...
                the function can be predefined or lambda...
                filter out all elements for which the function return true...
                the function need to ruturn boolean value...
                does not return false values...
        reduce()
                from functools import reduce => to import reduce function...
                take a function and iterator...
                run function on first and second element and give result...
                then run function on result and third element...
                then run function on result and forth element and so on...
                until one element is left in the iterator and this is the result...
                the function can be predefined or lambda...
        enumerate(iterable , start) => make the iterable enumerated...
        help(method) => return info about functions or methods...
        reversed(iterable) => return the items in reverse order...
        dir(object) => return all the data found the object...
        zip() => return a zip object contains all objects, it's length is the length of the lowest object...
module =>
        module is a file contain a set of functions...
        we can import module in our app to help us...
        we can import multiple modules...
        we can create our own modules...
aliasing => as => import module as md...
module => single file...
package => 
        files gathered together...
        external packages downloaded from the internet...
        we can install packages with python package manager => PIP...
        PIP install the package and it's dependencies...
datetime module functions =>
        datetime...
        time...
        now()...
        hour...
        minute...
        second...
        min...
        max...
        datetime(date , month , day) => specific date...
        strftime => return time formatted in a form of string...
        link for formatting => https://strftime.org/
iterable =>
        object contains data that can be iterated upon...
        examples => string, list, set, tuple, dictionary...
iterator =>
        object used to iterate over iterable using next() method...
        next() => return 1 element of iterable at a time...
        we can generate iterator from iterable using iter() method...
        for loop already calls iter() on the iterable...
generators =>
        generator is a function with "yield" key word not "return"...
        it support iteration and return generator iterator by calling "yield"...
        generator function can have one or more yield...
        by using next() it resumes from where "yield" is called not from begining...
        when called, it does not start automatically, it just give us the control...
decorators =>
        sometimes called meta programming...
        decorator take a function, add some functionality and return it...
        decorator wrap other function and enhance their behaviour...
        decorator is higher order function...
        @ + decorator name => sugar sintax before any function we want to decorate...
        can apply more than one decorator on a function...
pillow module =>
        deals with images easily...
        its sintax is PIL...
        PIL methods =>
                open("path") => take the path of the image and open it deal with it...
                crop(tuple of the dimensions) => crop the image...
                show() => show the image...
                convert("mode") => convert image mode...
                link for more => https://pillow.readthedocs.io/en/stable/
doc string =>
        Documentation string for class, module or function...
        can be accessed from the help and DOC attributes...
        made for understanding the the functionality of the complex code...
        single line documentation => ''' text for understanding the functionality ''' ...
        multiple line documentation => """ text for understanding the functionality """ ...
errors and exceptions raising =>
                exceptions is a runtime error reporting mechanism...
                exception gives us the message to understand the problem...
                traceback gives you the line to look for the code in this line...
                types of exceptions => syntax error, index error, key error etc...
                "raise" keyword used to raise our own exceptions...
                raising exception => raise Exception("error message")...
exception handling =>
        try => test the code for errors...
        except => handle the errors...
        else => if there is no errors...
        finally => run the code...
        try can have more than one except statement...
debugging way =>
        put a breakpoint at every line of code we want to debug...
        run and debug using continue button...
type hinting => using (->) + datatype(int, str, float, etc.) after function prototype...
regular expressions =>
        sequence of characters that define a search pattern...
        regular expression is not in python it's general concept...
        used in =>
                credit card validation, IP address validation, email validation...
        test RegEx: https://pythex.org/      or      https://regex101.com/
        characters cheatsheet: https://www.debuggex.com/cheatsheet/regex/python
        \b => backspace character...
        \d => one digit...
        \D => one non-digit...
        \s => one white space...
        \S => one non-white space...
        \w => one word character...
        . => any character except newline...
        a => char a...
        * => 0 or more...
        + => one or more...
        ? => 0 or 1 if char found: match, else: do not match...
        {n} => repeat n of times...
        {n1,n2} => between n1 and n2...
        {n,} => minimum is n...
        {,n} => maximum is n...
        [ab,d] => one character of a,b,c,d...
        [^ab,d] => one character except a,b,c,d...
        ^ => start of the line...
        $ => end of the line...
        | => or...
        \ => escape special character...
        () => seperate group...
        e-mail matching => ^[A-z0-9\.]+@[A-z0-9]+\.[A-z]+$
        e-mail matching => ^[A-z0-9\.]+@[A-z0-9]+\.(com|net|org)$
        list matching => (\d-|\d\)|\d>)(\w+)
        websites matching => (https?)://(www)?\.?(\w+)\.(\w+):?(\d+)?/?(.+)
regular expression module => re module...
re =>
        search(r"pattern","string") => search a string for a match and return the first match only...
        findall(r"pattern","string") => returns a list of all matches or return empty list if no match...
        split(pattern, string, maxSplit) => split => returns a list of elements splitted on each match...
        sub(pattern, replace, string, replaceCount) => replace matches with what you want...
        patternResult.span() => return index of the matched string...
        patternResult.string => return the string we searched in...
        patternResult.group => return group of repeated characters...
        patternResult.group() => return all matched groups together...
        patternResult.groups() => return each group alone in a tuple...
        flags =>
                re.M => multiline...
                re.I => ignorecase...
                re.DOTALL => (.) matches all...
OOP =>
        python supports OOP...
        OOP => Object Oriented Programming...
        OOP => paradigm or coding style...
        paradigm => means structuring program so the methods and attributes are bundled together...
        methods => act as function that use the information of the object...
        python => supports procedural, OOP and functional programming...
        functional => built on the concept of mathematical functions...
        procedural => structure app like recipe, sets of steps to make the task...
        OOP => allows you to organize your code and make it readable and reusable...
        every thing in python is object...
        class is a templete for creating objects (Object constructor | blueprint)...
class =>
        class => blueprint oe a constructor of the object...
        class instantiate means create instance of a class...
        instance => object created from class and have class's methods and data...
        class defined with keyword class...
        class name is written in pascalCase...
        class contains methods and attributes...
        when creating object python looks the built in __init__ method...
        __init__ method called every time you create object from class...
        __init__ method initialize the data for the object...
        __init__ method => constructor...
dunder or magic method => every method starts and ends with two underscore...
self => refer to the current instance created from the class...
self => must be the first parameter for the __init__ method...
self => can be named any thing...
class syntax => class className:
                                constructor => do instantiation (create objects)
                                def __init__ (self, other data):
                                        function body
self parameter => points at the instance (object) created from class...
instance attributes => defined inside the constructor...
we call attributes and methods using self...
class attributes => defined outside the constructor...
any method inside the class must take self as a parameter + any other data...
class method =>
        marked with @classmethod decorator to flag it as class method...
        it takes (cls) parameter not (self) to point to the class not instance...
        it does not require creation of class instance...
        used when we want to something with the class itself...
static method =>
        it does not require any parameter, it can take but not self or cls...
        it's related to the class not the instance...
        used when we want to do something to the class not the instance and it does not have to access object...
types of OOP methods => 
                constructor method => __init__ method => self as a parameter...
                instance method => self as a parameter...
                class method => cls as a parameter...
                static method => requires no parameter...
magic methods =>
        __init__ => called automatically when instantiating class...
        self.__class__ = the class to which the intance belong...
        __str__ => gives human readable output about the object...
        __len__ => returns the length of the container...
        __len__ => called when we use the built-in len() function on the object...
inheritance =>
        base class => the class which is inherited...
        derived class => the class which inherit attributes and methods from the base class...
inheritance way =>
        code in the derived class =>
                class DerivedClassName(BaseClassName)
        code in the constructor of the base class =>
                super().__init__(attribute1, attribute2, ...)
                Or
                BaseClassName().__init__(self, attribute1, attribute2, ...)
method overriding => repeat the same name and code of the method in the derived class...
mro() => method resolution order => return the order of base classes gevin to the derived class...
multiple inheritance => derived class inherit from derived class which inherit from the base class...
polymorphism => the same method name repeated in another class with different functionality...
polymorphism => we should raise NotImplementedError() Exception in the original method...
encapsulation => restrict access to the data stored in attributes and methods...
encapsulation => public, private, protected...
public => attributes and methods can be modified and run from everywhere inside and outside theclass...
protected => attributes and methods are accessed by the class and the derived class, prefixed with one underscore(_)...
protected => in python it can be accessed any where...
private => cannot be accessed or modified outside the class or object from this class and prefixed with double underscore(__)...
to access private data from outside => print(objectName._ClassName__attribute)...
python => no data restriction it's just naming rule for developers...
getter method => return the content of the attribute...
setter method => modify the content of the attribute...
@property => to make a method act as a property and call it without the brackets of the method like attributes...
ABCs => abstract base class...
abstract class => is a class has one or more abstract method...
abstract class => can not be instantiated...
abc module => in python provides infrastructure for defining custom abstract base classes...
@abstractmethod => decorator on the methods to make it abstract...
ABCMeta class => is a meta class used for defining abstract base class...
to make abstract class => 
        first: we have to import ABCMeta and abstractmethod from abc module...
        second: we have to @abstractmethod before the method we wish to make it abstract...
        third: put pass inside the body of the abstract method...
Databases =>
        database => is where we can store data
        database => is organized into tables (users, categories, ...)...
        tables => has columns (Id, username, password, ...)...  
        SQL => structured query language...
        SQLlite => can run in memory or in a single file...
        data inside database has types (text, integer, date)...
table creation => CREATE TABLE skills (name text, progress integer, user_id integer)...
cursor => all operations in the database are done by the cursor not the connection...
commit => save all changes made in the database...
fetchone() => returns a single record / a row or none if all rows are finished...
fetchall() => returns/fetches all the rows of a query result as a list of tuples, empty list if they are finished...
fetchmany(n) => return n of rows from database...
every fetched row is a tuple and all rows are list of tuples...
avoiding sql injection => for data security => make the inserted data in a tuple and pass the tuple to execute() after the query and put placeholders in the query...
order by => ordering returned data...
limit n => return only n records...
offset n => skip the first n records and return the remainder of the table...
in(n1, n2, ...) or nt in(n1, n2, ...)=> return the data with this specifications only...
advanced lessons =>
        __name__ => built-in variable...
        __main__ => value of the __name__ variable...
        __name__ is assigned to __main__ in the directly run method and not in import method... 
execution methods of files => 
        directly from cmd or run button...
        from import inside another file...
if we import file in another file it runs all its commands in that file...
timeit module => get execution time of code by running 1million time and give you the minimal time...
timeit method => timeit(stmt, setup, timer, number)...
stmt => code you want to measure the execution time for...
setup => done before the code execution as importing module or anything...
timer => the timer value...
number => how many executions will be done on the code...
repeat() => work like timeit but repeat the execution number of times in attribute repeat = n...
logging => info about errors and warnings about the code printed in console or into file...
levels of logging => debug, info, warning, error,critical...
logging method => basicConfig(filename, filemode, format, level)
getLogger() => return a logger with the specified name...
testing =>
        test runner => the module that run the unit testing (unittest , pytest)...
        test case => smallest unit of testing, it uses assertion methods to check for actions and responses...
        test suite => collection of multiple test cases...
        test report => full report contains the failure or success...
        unittest module =>
                add tests into classes as methods...
                use a series of special assertion methods...
